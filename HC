import random
import numpy as np
import matplotlib.pyplot as plt

# Parámetros del barco
capacidad_barco = 200  # toneladas de capacidad

# Generar áreas de pesca (10 áreas en coordenadas 2D)
def generar_areas_pesca(n_areas):
    posiciones = np.random.rand(n_areas, 2) * 100  # coordenadas en un plano 2D
    clima = np.random.randint(0, 10, size=n_areas)  # Índice de clima (0 a 10)
    oleaje = np.random.randint(0, 10, size=n_areas)  # Índice de oleaje (0 a 10)
    peces = np.random.randint(1, 150, size=n_areas)  # Cantidad de peces en cada área (0 a 100)
    
    return posiciones, clima, oleaje, peces

# Función para calcular la distancia euclidiana entre dos puntos
def calcular_distancia(p1, p2):
    return np.sqrt(np.sum((p1 - p2) ** 2))

# Función para evaluar la calidad de una ruta
def evaluar_ruta(ruta, posiciones, clima, oleaje, peces, capacidad_barco):
    distancia_total = 0
    peces_recolectados = 0
    carga_total = 0
    clima_total = 0
    oleaje_total = 0
    
    for i in range(len(ruta) - 1):
        # Calcular la distancia
        distancia_total += calcular_distancia(posiciones[ruta[i]], posiciones[ruta[i + 1]])
        
        # Sumar condiciones climáticas y oleaje
        clima_total += clima[ruta[i]]
        oleaje_total += oleaje[ruta[i]]
        
        # Recolectar peces si no excede la capacidad del barco
        if carga_total + peces[ruta[i]] <= capacidad_barco:
            peces_recolectados += peces[ruta[i]]
            carga_total += peces[ruta[i]]
    
    # Sumar la distancia de regreso al punto de partida
    distancia_total += calcular_distancia(posiciones[ruta[-1]], posiciones[ruta[0]])
    
    # Retornar una evaluación que minimice distancia y riesgos, y maximice peces
    return peces_recolectados, clima_total, oleaje_total, distancia_total

# Generador de soluciones (rutas aleatorias)
def generar_rutas_aleatorias(n_rutas, n_areas):
    rutas = []
    for _ in range(n_rutas):
        rutas.append(random.sample(range(n_areas), n_areas))
    return rutas

# Evaluador de soluciones
def hill_climbing_pesca(n_rutas, max_iter=1000):
    # Generar áreas de pesca
    posiciones, clima, oleaje, peces = generar_areas_pesca(n_areas=10)
    
    # Generar soluciones (rutas aleatorias)
    rutas = generar_rutas_aleatorias(n_rutas=n_rutas, n_areas=10)
    
    mejor_ruta = None
    mejor_peces = 0
    mejor_clima = float('inf')
    mejor_oleaje = float('inf')
    mejor_distancia = float('inf')
    
    # Evaluar las rutas
    for ruta in rutas:
        peces_recolectados, clima_total, oleaje_total, distancia_total = evaluar_ruta(
            ruta, posiciones, clima, oleaje, peces, capacidad_barco
        )
        
        # Criterio de selección: Maximizar peces, minimizar clima y oleaje, y minimizar distancia
        if peces_recolectados > mejor_peces or (
            peces_recolectados == mejor_peces and (clima_total < mejor_clima or oleaje_total < mejor_oleaje)
        ):
            mejor_ruta = ruta
            mejor_peces = peces_recolectados
            mejor_clima = clima_total
            mejor_oleaje = oleaje_total
            mejor_distancia = distancia_total
    
    return mejor_ruta, mejor_peces, mejor_clima, mejor_oleaje, mejor_distancia, posiciones

# Graficar la mejor ruta de pesca con nombres de sectores marítimos
def graficar_ruta_pesca(ruta, posiciones, mejor_peces, mejor_clima, mejor_oleaje, mejor_distancia, sectores_maritimos):
    plt.figure(figsize=(10, 10))
    
    # Graficar los puntos de las áreas de pesca con nombres de sectores marítimos
    for i, punto in enumerate(posiciones):
        plt.scatter(punto[0], punto[1], color='blue', s=100)
        plt.text(punto[0] + 1, punto[1] + 1, sectores_maritimos[i], fontsize=12)  # Nombres de sectores marítimos
    
    # Graficar las rutas
    for i in range(len(ruta) - 1):
        p1 = posiciones[ruta[i]]
        p2 = posiciones[ruta[i + 1]]
        plt.plot([p1[0], p2[0]], [p1[1], p2[1]], 'k--')
    
    # Añadir la línea de regreso al punto inicial
    p1 = posiciones[ruta[-1]]
    p2 = posiciones[ruta[0]]
    plt.plot([p1[0], p2[0]], [p1[1], p2[1]], 'k--')
    
    # Añadir detalles
    plt.title(f"Ruta de Pesca: Peces = {mejor_peces}, Clima = {mejor_clima}, Oleaje = {mejor_oleaje}, Distancia = {mejor_distancia:.2f}", fontsize=14)
    plt.xlabel('Coordenada X')
    plt.ylabel('Coordenada Y')
    
    plt.grid(True)
    plt.show()

# Lista de nombres de sectores marítimos
sectores_maritimos = [
    "Bahía Azul", "Costa Verde", "Roca del Faro", "Mar de Plata", 
    "Isla Cristal", "Cabo Tempestad", "Ensenada Serena", 
    "Golfo Estrella", "Punta del Sol", "Laguna Escondida"
]

# Ejecutar el algoritmo de Hill Climbing para rutas de pesca
mejor_ruta, mejor_peces, mejor_clima, mejor_oleaje, mejor_distancia, posiciones = hill_climbing_pesca(n_rutas=100, max_iter=1000)

# Graficar la mejor ruta con los nombres de sectores marítimos
graficar_ruta_pesca(mejor_ruta, posiciones, mejor_peces, mejor_clima, mejor_oleaje, mejor_distancia, sectores_maritimos)
